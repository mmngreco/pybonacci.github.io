<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="author" content="Pybonacci">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width">
        <title>Estadística en Python con SciPy (I) | Pybonacci</title>

	<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
	<link rel="icon" href="/favicon.ico" type="image/x-icon">
        <link rel="alternate" type="application/atom+xml" title="Pybonacci blog atom feed" href="/feeds/all.atom.xml" />
        <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700' rel='stylesheet' type='text/css'>

        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
        <link rel="stylesheet" type="text/css" href="/theme/css/fontello.css"/>
        <style>.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #60a0b0; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #007020; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #007020 } /* Comment.Preproc */
.highlight .c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
.highlight .cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #007020; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #007020 } /* Keyword.Pseudo */
.highlight .kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #902000 } /* Keyword.Type */
.highlight .m { color: #40a070 } /* Literal.Number */
.highlight .s { color: #4070a0 } /* Literal.String */
.highlight .na { color: #4070a0 } /* Name.Attribute */
.highlight .nb { color: #007020 } /* Name.Builtin */
.highlight .nc { color: #0e84b5; font-weight: bold } /* Name.Class */
.highlight .no { color: #60add5 } /* Name.Constant */
.highlight .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #d55537; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #007020 } /* Name.Exception */
.highlight .nf { color: #06287e } /* Name.Function */
.highlight .nl { color: #002070; font-weight: bold } /* Name.Label */
.highlight .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #062873; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #bb60d5 } /* Name.Variable */
.highlight .ow { color: #007020; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #40a070 } /* Literal.Number.Float */
.highlight .mh { color: #40a070 } /* Literal.Number.Hex */
.highlight .mi { color: #40a070 } /* Literal.Number.Integer */
.highlight .mo { color: #40a070 } /* Literal.Number.Oct */
.highlight .sb { color: #4070a0 } /* Literal.String.Backtick */
.highlight .sc { color: #4070a0 } /* Literal.String.Char */
.highlight .sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #4070a0 } /* Literal.String.Double */
.highlight .se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #4070a0 } /* Literal.String.Heredoc */
.highlight .si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
.highlight .sx { color: #c65d09 } /* Literal.String.Other */
.highlight .sr { color: #235388 } /* Literal.String.Regex */
.highlight .s1 { color: #4070a0 } /* Literal.String.Single */
.highlight .ss { color: #517918 } /* Literal.String.Symbol */
.highlight .bp { color: #007020 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #bb60d5 } /* Name.Variable.Class */
.highlight .vg { color: #bb60d5 } /* Name.Variable.Global */
.highlight .vi { color: #bb60d5 } /* Name.Variable.Instance */
.highlight .il { color: #40a070 } /* Literal.Number.Integer.Long */</style>
        <style>.description-author {
  font-size: 0.8em;
  color: #333;
}
.img-author {
  max-height: 10em;
  max-width: 10em;
}
body {
  margin: 0;
  padding: 0;
  font: 15px 'Source Sans Pro', sans-serif;
  line-height: 1.6em;
  color: #222222;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
}
a {
  color: #007ee5;
  text-decoration: none;
}
a:hover {
  color: #007ee5;
  text-decoration: none;
}
header.main-header {
  background: none repeat scroll 0% 0% #205F29;
  margin-bottom: 0px;
}
header.main-header a {
  color: #fff;
}
header.main-header .container {
  max-width: 1000px;
}
header.main-header .container nav a:hover {
  background-color: #5C881C;
}
header.navbar-default {
  border-bottom: none;
  background-color: #EFEFEF;
}
article {
  margin: 0;
}
article header.about {
  margin-bottom: 0px;
  padding-bottom: 0px;
}
article header {
  padding-bottom: 20px;
}
article header h1 {
  margin-bottom: 2px;
  font-weight: 700;
  color: #000;
}
article header time {
  color: #9E9E9E;
  float: right;
}
article header time.left {
  color: #9E9E9E;
  float: left;
}
article div.social-links ul {
  padding: 0px;
}
article div.social-links li {
  display: inline;
  font-size: 20px;
}
article div.social-links li a {
  color: #000;
  padding: 10px;
}
article div.social-links li a:hover {
  color: #666;
  text-decoration: none;
}
article p {
  font-size: 2em;
  margin-bottom: 20px;
  line-height: 1.6em;
  text-align: justify;
}
article p.note {
  background: #f5f5f5;
  border: 1px solid #ddd;
  padding: 0.533em 0.733em;
}
article p.update {
  background-color: #FEEFB3;
  border: 1px solid #e6e68a;
  padding: 0.533em 0.733em;
}
article p.alert {
  background-color: #ffe2e2;
  border: 1px solid #ffb2b2;
  padding: 0.533em 0.733em;
}
article ul,
article ol {
  margin-top: 0px;
  margin-bottom: 25px;
}
article li {
  font-size: 16px;
  line-height: 1.6em;
}
article a:hover {
  text-decoration: underline;
}
article blockquote {
  border-left: 2px solid #c7c7cc;
  color: #666;
  margin: 30px 0;
  padding: 0 0 0 25px;
}
article img {
  max-width: 100%;
}
article code {
  color: #333;
  background-color: #EEE;
  border-radius: 0;
  font-size: 1em;
}
article .meta {
  margin-top: 35px;
}
article .meta a:hover {
  text-decoration: none;
}
article .meta div {
  display: block;
}
article .meta address:before,
article .meta time:before,
article .meta a.tag:before {
  font-family: 'fontello';
  margin-right: 6px;
}
article .meta address.author {
  float: left;
}
article .meta address:before {
  content: '\e819';
}
article .meta time:before {
  content: '\f133';
}
article .meta div.tags {
  clear: both;
}
article .meta a.tag {
  margin: 0 10px 10px 0;
  padding: 1px 12px;
  display: inline-block;
  font-size: 14px;
  color: rgba(0, 0, 0, 0.8);
  background: rgba(0, 0, 0, 0.05);
}
article .meta a.tag:before {
  content: '\e821';
}
article .meta a.tag:hover {
  background: rgba(0, 0, 0, 0.15);
}
article .meta a.read_more,
article .meta a.comments_btn {
  font-size: 14px;
  font-weight: 800;
  padding: 10px 20px;
  color: #007aa3;
  background: #FFF;
  border: 1px solid #007aa3;
}
article .meta a.read_more:hover,
article .meta a.comments_btn:hover {
  color: #FFF;
  background: #007aa3;
}
article .meta:after {
  content: "";
  display: table;
  clear: both;
}
.index {
  max-width: 700px;
}
.index article header h2 {
  font-size: 36px;
  margin-bottom: 2px;
  font-weight: 700;
}
.index article header h2 a {
  color: #333;
}
.index article header h2 a:hover {
  color: #007ee5;
  text-decoration: none;
}
.index .separator {
  padding: 40px 0 0 0;
  margin: 0 0 40px 0;
  height: 10px;
  border-bottom: solid 1px #CCC;
}
.index .pagination {
  display: block;
  margin-bottom: 100px;
}
.index .pagination .left {
  text-align: right;
}
.index .pagination .right {
  text-align: left;
}
.index .pagination a {
  display: inline-block;
  border: 2px solid #5C881C;
  margin: 0 5px;
  padding: 8px 20px;
  font-weight: bold;
  color: #5C881C;
}
.index .pagination a:hover {
  color: #FFF;
  background: #5C881C;
}
.post {
  max-width: 80%;
}
.post h1 {
  font-size: 42px;
}
.post h2:before {
  content: "# ";
  font-weight: bold;
  color: #DDD;
}
.post h3:before {
  content: "## ";
  font-weight: bold;
  color: #DDD;
}
.post h4:before {
  content: "### ";
  font-weight: bold;
  color: #DDD;
}
.post p {
  font-size: 2em;
}
.list {
  max-width: 700px;
}
.list ul.double-list {
  margin: 0 auto 60px;
  padding: 0;
  list-style-type: none;
}
.list ul.double-list li {
  padding: 5px 0;
}
.list ul.double-list li h2 {
  font-size: 2em;
  display: inline;
  font-weight: normal;
}
.list ul.double-list li span {
  font-family: sans-serif;
  text-transform: uppercase;
  text-align: right;
  float: right;
  padding-top: 3px;
  font-size: 12px;
  color: #999;
}
.full-width-content {
  padding-top: 10px;
  padding-left: 0px;
  padding-right: 0px;
  margin-left: -20px;
  margin-right: -20px;
}
.col-xs-1,
.col-sm-1,
.col-md-1,
.col-lg-1,
.col-xs-2,
.col-sm-2,
.col-md-2,
.col-lg-2,
.col-xs-3,
.col-sm-3,
.col-md-3,
.col-lg-3,
.col-xs-4,
.col-sm-4,
.col-md-4,
.col-lg-4,
.col-xs-5,
.col-sm-5,
.col-md-5,
.col-lg-5,
.col-xs-6,
.col-sm-6,
.col-md-6,
.col-lg-6,
.col-xs-7,
.col-sm-7,
.col-md-7,
.col-lg-7,
.col-xs-8,
.col-sm-8,
.col-md-8,
.col-lg-8,
.col-xs-9,
.col-sm-9,
.col-md-9,
.col-lg-9,
.col-xs-10,
.col-sm-10,
.col-md-10,
.col-lg-10,
.col-xs-11,
.col-sm-11,
.col-md-11,
.col-lg-11,
.col-xs-12,
.col-sm-12,
.col-md-12,
.col-lg-12 {
  padding-right: 0px;
  padding-left: 0px;
}
.disclaimer {
  text-align: center;
  background-color: #EFEFEF;
  border-bottom: none;
  margin-top: 6em;
}</style>

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?..." type="text/javascript"></script>
        <script type="text/javascript">
        init_mathjax = function() {
            if (window.MathJax) {
                // MathJax loaded
                MathJax.Hub.Config({
                    tex2jax: {
                        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                        displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
                    },
                    displayAlign: 'left', // Change this to 'center' to center equations.
                    "HTML-CSS": {
                        styles: {'.MathJax_Display': {"margin": 0}}
                    }
                });
                MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
            }
        }
        init_mathjax();
        </script>

    </head>

    <body>
        <header class="navbar navbar-default bs-docs-nav">
            <div class="container-fluid">
                <div class="navbar-header">
		  <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#theNavbar">
		    <span class="icon-bar"></span>
		    <span class="icon-bar"></span>
		    <span class="icon-bar"></span> 
		  </button>
                  <a class="navbar-brand" href="/" title="Home" class="title">Pybonacci</a><!-- — Python y Ciencia-->
                </div>
                <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation" id="theNavbar">
		    <ul class="nav navbar-nav navbar-right">
                            <li><a href="/pages/acerca-de-pybonacci.html" title="About">Acerca de</a></li>
                            <li><a href="/archives.html" title="Archive">Archivos</a></li>
                            <li><a class="nodec icon-rss" href="/feeds/all.atom.xml" title="pybonacci.github.io RSS feed" rel="me"></a></li>
                    </ul>
                </nav>
            </div>
        </header>

        <div id="wrap">
<div class="container post">
    <article>
        <header>
            <h1>Estadística en Python con SciPy (I)</h1>
            <div class="meta">
                <time datetime="article.date.isoformat()" pubdate>sáb 21 abril 2012</time>
                <address class="vcard author">Por
                    <a class="url fn" href="http://pybonacci.github.io/author/juan-luis-cano.html">Juan Luis Cano</a>
                </address>
            </div>
        </header>

        <div class="article_content">
            <h2>Introducción</h2>
<p>Hoy vamos a ver cómo trabajar con variable aleatoria con el módulo <code>stats</code> de la biblioteca Scipy. Scipy viene con numerosas <a href="http://docs.scipy.org/doc/scipy/reference/stats.html">distribuciones de probabilidad</a>, tanto discretas como continuas, y además pone a nuestra disposición herramientas para crear nuestras propias distribuciones y multitud de herramientas para hacer cálculos estadísticos. En esta primera parte nos centraremos en cómo manejar esas distribuciones y sus funciones de distribución, cómo representarlas con matplotlib y cómo definir nuevas distribuciones.</p>
<p><em><strong>En esta entrada se ha usado python 2.7.3, numpy 1.6.1, matplotlib 1.1.0 y scipy 0.10.1.</strong></em></p>
<!--more-->

<p><strong>Nota:</strong> En mi opinión la documentación de este módulo deja un poco que desear. No resulta demasiado didáctica, hay algunas imprecisiones y cosas que directamente no tienen sentido o están mal. En cuanto sepas manejarlo un poco puedes usar de referencia en primer enlace de la entrada.</p>
<h2>Distribuciones de variable continua</h2>
<p>Entre las muchas <a href="http://docs.scipy.org/doc/scipy/reference/stats.html#continuous-distributions">distribuciones continuas</a> que tiene SciPy vamos a ver un ejemplo de cómo manejar la distribución normal o gaussiana. Primero vamos a importar un par de módulos</p>
<pre><code class="language-python">In [1]: import numpy as np
In [2]: import scipy.stats as st</code></pre>

<p>Todas las distribuciones continuas están definidas en función de dos <strong>parámetros</strong>: <code>loc</code> y <code>scale</code>, que juegan distinto papel en función de la distribución que manejemos. Por ejemplo, para la normal, <code>loc</code> es la media y por tanto el centro de la distribución y <code>scale</code> es la desviación típica y puede verse como un factor de escala (de ahí los nombres de los parámetros). Por otro lado, para la distribución uniforme, <code>loc</code> y <code>scale</code> son los extremos del intervalo en el que toma valores la variable.</p>
<p>Tenemos dos formas de manejar las distribuciones: una de ellas es crear un objeto que represente a <strong>la distribución con los parámetros fijados</strong>, y acceder después a todos sus métodos («frozen distribution»), de esta manera:</p>
<pre><code class="language-python">In [3]: rv1 = st.norm()  # Normal estándar
In [4]: rv1.cdf(0.5)  # Evaluamos la función de distribución en 0.5
Out[4]: 0.69146246127401312
In [5]: x = np.linspace(0.0, 1.0)
In [6]: rv1.pdf(x)  # Densidad de probabilidad en el intervalo [0.0, 1.0]
Out[6]:
array([ 0.39894228,  0.39885921,  0.39861011,  0.39819528,  0.39761524,
        0.39687072,  0.39596264,  0.39489214,  0.39366054,  0.39226937,
        0.39072035,  0.38901539,  0.38715659,  0.38514623,  0.38298676,
        0.38068082,  0.37823119,  0.37564085,  0.37291289,  0.37005059,
        0.36705736,  0.36393672,  0.36069236,  0.35732807,  0.35384775,
        0.35025541,  0.34655518,  0.34275126,  0.33884794,  0.33484957,
        0.3307606 ,  0.3265855 ,  0.32232884,  0.31799518,  0.31358916,
        0.30911541,  0.30457861,  0.29998342,  0.29533453,  0.29063661,
        0.28589432,  0.28111231,  0.27629519,  0.27144753,  0.26657387,
        0.26167871,  0.25676648,  0.25184154,  0.24690821,  0.24197072])
In [7]: rv2 = st.norm(2.0, 0.0)  # Normal (2.0, 0.0)
In [8]: rv3 = st.norm(loc=-1.0, scale=np.sqrt(0.5))  # Media -1.0 y varianza 0.5</code></pre>

<p>La otra manera sería llamar en cada momento a la función que queramos evaluar, pasando los parámetros correspondientes, de manera que no se crea una distribución concreta:</p>
<pre><code class="language-python">In [9]: st.norm.cdf(0.5)  # Función de distribución de una normal estándar en 0.5
Out[9]: 0.69146246127401312
In [10]: st.norm.pdf(x, -1.0, np.sqrt(0.5))  # Densidad de una normal (-1.0, 0.5) en [0.0, 1.0]
Out[10]:
array([ 0.20755375,  0.19916976,  0.1909653 ,  0.18294635,  0.17511819,
        0.16748543,  0.16005198,  0.15282109,  0.14579538,  0.13897686,
        0.13236692,  0.12596638,  0.11977553,  0.11379411,  0.10802137,
        0.10245611,  0.09709665,  0.09194093,  0.08698648,  0.08223049,
        0.0776698 ,  0.07330098,  0.0691203 ,  0.06512379,  0.06130727,
        0.05766636,  0.05419651,  0.05089303,  0.04775112,  0.04476588,
        0.04193231,  0.0392454 ,  0.03670008,  0.03429126,  0.03201387,
        0.02986284,  0.02783314,  0.0259198 ,  0.02411789,  0.02242256,
        0.02082904,  0.01933266,  0.01792884,  0.01661312,  0.01538113,
        0.01422864,  0.01315155,  0.01214588,  0.01120776,  0.01033349])</code></pre>

<p>Esto será útil cuando queramos hacer ajustes o estimaciones sobre los parámetros de la distribución, como veremos en la próxima entrega.</p>
<p>Para quien no conozca los nombres en inglés, los métodos más importantes son</p>
<ul>
<li>Salida pseudoaleatoria («random variates» <code>rvs</code>)</li>
<li>Función densidad de probabilidad («probability density function» <code>pdf</code>)</li>
<li>Función de distribución («cumulative distribution function» <code>cdf</code>)</li>
</ul>
<p>y todos ellos, y alguno más, están <strong>vectorizados</strong>, lo que significa que les podemos pasar un array de NumPy y obtendremos un array de valores.</p>
<h3>Representación gráfica</h3>
<p>Como los métodos básicos están vectorizados, es muy sencillo representarlos gráficamente en la manera a la que estamos acostumbrados, utilizando arrays de NumPy. Simplemente tenemos que escribir</p>
<pre><code class="language-python">In [11]: import matplotlib.pyplot as plt
In [12]: x = np.linspace(0.0, 1.0)
In [13]: plt.plot(x, st.norm.pdf(x, -1.0, np.sqrt(0.5)))
Out[13]: []
In [14]: plt.show()</code></pre>

<p>Y podemos obtener bonitas figuras como esta.<figure id="attachment_217" style="width: 448px" class="wp-caption aligncenter"></p>
<p><a href="http://new.pybonacci.org/images/2012/04/normal_pdf1.png"><img class=" wp-image-217" title="Distribuciones normales" src="http://new.pybonacci.org/images/2012/04/normal_pdf1.png" alt="" width="448" height="336" srcset="https://pybonacci.org/wp-content/uploads/2012/04/normal_pdf1.png 800w, https://pybonacci.org/wp-content/uploads/2012/04/normal_pdf1-300x225.png 300w" sizes="(max-width: 448px) 100vw, 448px" /></a><figcaption class="wp-caption-text">Función de densidad de probabilidad de varias distribuciones normales (inspiración: http://commons.wikimedia.org/wiki/File:Normal_Distribution_PDF.svg)</figcaption></figure> </p>
<h3>Definir distribuciones</h3>
<p>La manera de crear nuestras propias distribuciones continuas con SciPy es extender la clase <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.html"><code>rv_continuous</code></a> y definir o bien su función de densidad o su función de distribución. Las clases y la herencia son conceptos de la <a href="http://es.wikipedia.org/wiki/Programaci%C3%B3n_orientada_a_objetos">Programación Orientada a Objetos</a>, pero no es nuestra intención meternos a fondo en estos temas. De igual manera que hemos hecho <code>rv = st.norm()</code> para crear un objeto distribución al que manipular, queremos un mecanismo parecido para hacer <code>rv = nueva_dist()</code>, y para eso hemos de definir <code>nueva_dist</code> primero.</p>
<p>Por ejemplo, supongamos que queremos definir una distribución uniforme cuya función de densidad es</p>
<p>$f(x) = -ln{x} quad x in (0, 1],$</p>
<p>el código sería el siguiente</p>
<pre><code class="language-python">In [15]: from scipy.stats import rv_continuous
In [16]: class variable_gen(rv_continuous):
   ....:     """Variable aleatoria continua de distribución logarítmica."""
   ....:     def _pdf(self, x):
   ....:         return -log(x)
   ....:
In [17]: variable_gen?
Type:       type
Base Class: &lt;type 'type'&gt;
String Form:&lt;class '__main__.variable_gen'&gt;
Namespace:  Interactive
Definition: variable_gen(self, *args, **kwds)
Docstring:  Variable aleatoria continua de distribución logarítmica.
Constructor information:
 Definition:variable_gen(self, momtype=1, a=None, b=None, xa=-10.0, xb=10.0, xtol=1e-14, badvalue=None, name=None, longname=None, shapes=None, extradoc=None)
In [18]: variable = variable_gen(a=0.0, b=1.0, name="variable")
In [19]: variable.pdf(0.0)
/usr/bin/ipython2:4: RuntimeWarning: divide by zero encountered in log
Out[19]: inf
In [20]: from scipy.integrate import quad
In [21]: from numpy import inf
In [22]: quad(variable.pdf, -inf, inf)
Out[22]: (0.9999999999999962, 6.149525333398742e-12)</code></pre>

<p>Lo que hemos hecho ha sido</p>
<ol>
<li>Definir la clase <code>variable_gen</code>, que hereda las propiedades de <code>rv_continuous</code>.</li>
<li>Escribir la cadena de documentación de la clase.</li>
<li>Definir su función de densidad de probabilidad.</li>
<li>Crear una nueva variable, <code>variable</code>, en la que guardamos un objeto distribución cuya variable recorre el intervalo $[0.0, 1.0]$ (nótese que es cerrado).</li>
<li>Comprobar qué pasa en 0. Nada que no supiéramos.</li>
<li>Comprobar que la función densidad está normalizada integrándola sobre la recta real (el primer número es el valor de la integral y el segundo una estimación del error, como podemos ver en la documentación de la función <code>&lt;a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html"&gt;quad&lt;/a&gt;)</code>.</li>
</ol>
<div>
  A partir de ahora podemos hacer lo mismo que hemos hecho antes: o bien crear una distribución fija o acceder a los métodos de la misma directamente. Aunque sólo hemos dado la función de densidad, comprobamos que también podemos llamar al resto:
</div>

<pre><code class="language-python">In [23]: rv = variable()  # Nótense los paréntesis
In [24]: rv.cdf(0.5)
Out[24]: 0.84657359027997248
In [25]: x = np.linspace(0.0, 1.0)
In [25]: rv.cdf(x)
Out[25]:
array([ 0.        ,  0.09983307,  0.17137441,  0.23223723,  0.28616538,
        0.33493698,  0.37959929,  0.42084431,  0.45916388,  0.49492574,
        0.52841535,  0.55986072,  0.58944824,  0.61733311,  0.64364656,
        0.66850105,  0.69199398,  0.71421058,  0.73522599,  0.75510704,
        0.77391348,  0.79169908,  0.8085125 ,  0.82439796,  0.83939582,
        0.8535431 ,  0.86687383,  0.87941944,  0.89120902,  0.90226958,
        0.91262628,  0.92230257,  0.93132042,  0.93970041,  0.94746188,
        0.95462303,  0.961201  ,  0.96721201,  0.97267137,  0.97759362,
        0.98199253,  0.98588117,  0.98927201,  0.99217689,  0.99460713,
        0.9965735 ,  0.99808632,  0.99915544,  0.99979032,  1.        ])
In [26]: rv.rvs()
Out[26]: 0.11391190950607678
In [27]: rv.rvs()
Out[27]: 0.41700479602973284
In [28]: rv.rvs()
Out[28]: 0.00019824204606004107</code></pre>

<h2>Distribuciones de variable discreta</h2>
<p>Scipy también trae unas cuantas <a href="http://docs.scipy.org/doc/scipy/reference/stats.html#discrete-distributions">distribuciones discretas</a> para que no las tengamos que definir nosotros, y se usan de manera similar a las continuas. Por ejemplo, la distribución binomial:</p>
<pre><code class="language-python">In [29]: rv = st.binom(5, 0.5)  # Experimento de Bernoulli 5 veces con probabilidad 0.5
In [30]: k = np.arange(6)
In [31]: pk = rv.pmf(k)
In [32]: pk
Out[32]: array([ 0.03125,  0.15625,  0.3125 ,  0.3125 ,  0.15625,  0.03125])</code></pre>

<p>Para el caso de distribuciones discretas, la función de densidad se distribuye por la función de probabilidad («probability mass function» <code>pmf</code>).</p>
<h3>Representación gráfica</h3>
<p>Ahora representar gráficamente una distribución discreta tiene un poco más de enjundia que en el caso de distribuciones continuas. Para la función de probabilidad hay al menos dos opciones, en función de los gustos de cada cual: hacer un diagrama de barras con <a href="http://matplotlib.sourceforge.net/api/pyplot_api.html#matplotlib.pyplot.bar"><code>bar</code></a> o uno de líneas verticales con <a href="http://matplotlib.sourceforge.net/api/pyplot_api.html#matplotlib.pyplot.vlines"><code>vlines</code></a>, como vemos en este fragmento de código:</p>
<pre><code class="language-python">In [33]: plt.vlines(k, 0, pk)  # El segundo argumento da el extremo inferior de las líneas
Out[33]:
In [34]: plt.plot(k, pk, 'o')  # Añadimos puntos en los extremos
Out[34]: []
In [35]: plt.show()
In [36]: plt.bar(k - 0.5, _81, width=1.0)  # Se resta 0.5 para que las barras estén centradas
Out[36]:
In [37]: plt.show()</code></pre>

<p>Se obtienen resultados similares a estos:<figure id="attachment_232" style="width: 300px" class="wp-caption aligncenter"></p>
<p><a href="http://new.pybonacci.org/images/2012/04/binomial5_05_pmf.png"><img class="size-medium wp-image-232" title="Binomial (5, 1/2)" src="http://new.pybonacci.org/images/2012/04/binomial5_05_pmf.png?w=300" alt="" width="300" height="225" srcset="https://pybonacci.org/wp-content/uploads/2012/04/binomial5_05_pmf.png 800w, https://pybonacci.org/wp-content/uploads/2012/04/binomial5_05_pmf-300x225.png 300w" sizes="(max-width: 300px) 100vw, 300px" /></a><figcaption class="wp-caption-text">Función de probabilidad de una distribución binomial (5, 1/2) con líneas verticales</figcaption></figure> <figure id="attachment_233" style="width: 300px" class="wp-caption aligncenter"><a href="http://new.pybonacci.org/images/2012/04/binomial5_05_pmf2.png"><img class="size-medium wp-image-233" title="Distribución binomial (5, 1/2)" src="http://new.pybonacci.org/images/2012/04/binomial5_05_pmf2.png?w=300" alt="" width="300" height="225" srcset="https://pybonacci.org/wp-content/uploads/2012/04/binomial5_05_pmf2.png 800w, https://pybonacci.org/wp-content/uploads/2012/04/binomial5_05_pmf2-300x225.png 300w" sizes="(max-width: 300px) 100vw, 300px" /></a><figcaption class="wp-caption-text">Función de probabilidad de una distribución binomial (5, 1/2) con barras</figcaption></figure> </p>
<p>Para la función de distribución, sabemos que en el caso discreto esta tiene discontinuidades de salto. Para no obtener una gráfica horrible con puntos unidos que no deberían estarlo, o bien hacemos otro diagrama de barras o utilizamos <strong>arrays enmascarados</strong> («masked arrays» suena menos chistoso). Los <a href="http://docs.scipy.org/doc/numpy/reference/maskedarray.generic.html#what-is-a-masked-array">masked arrays</a> con arrays de NumPy en los que, bien manualmente o bien siguiendo alguna regla o patrón, hemos marcado algunas entradas como inválidas. Son de utilidad cuando, por ejemplo, estamos recogiendo datos y queremos descartar los que sean erróneos o se alejen demasiado de la media.</p>
<p>Si representamos gráficamente arrays enmascarados, matplotlib <em>no</em> unirá los puntos correspondientes a entradas inválidas, que es exactamente lo que queremos (como podemos leer <a href="http://stackoverflow.com/a/2543391/554319">en esta respuesta de StackOverflow</a>). Los elementos que queremos marcar como inválidos son aquellos en los que la función da un salto, por lo que comprobaremos la diferencia entre un elemento y el siguiente del array. Para ello usaremos la función <code>roll</code> de NumPy:</p>
<pre><code class="language-python">In [38]: rv = st.binom(5, 0.5)
In [39]: x = np.linspace(-0.5, 5.5)
In [40]: cdf = rv.cdf(x)
In [41]: deltas = cdf - np.roll(cdf, 1)  # Array de diferencias
In [42]: deltas
Out[42]:
array([-1.     ,  0.     ,  0.     ,  0.     ,  0.     ,  0.03125,
        0.     ,  0.     ,  0.     ,  0.     ,  0.     ,  0.     ,
        0.     ,  0.15625,  0.     ,  0.     ,  0.     ,  0.     ,
        0.     ,  0.     ,  0.     ,  0.3125 ,  0.     ,  0.     ,
        0.     ,  0.     ,  0.     ,  0.     ,  0.     ,  0.3125 ,
        0.     ,  0.     ,  0.     ,  0.     ,  0.     ,  0.     ,
        0.     ,  0.15625,  0.     ,  0.     ,  0.     ,  0.     ,
        0.     ,  0.     ,  0.     ,  0.03125,  0.     ,  0.     ,
        0.     ,  0.     ])
In [43]: cdf = np.ma.masked_where(abs(deltas) &gt; tol, cdf)
In [44]: cdf
Out[44]:
masked_array(data = [-- 0.0 0.0 0.0 0.0 -- 0.03125 0.03125 0.03125 0.03125 0.03125 0.03125
 0.03125 -- 0.1875 0.1875 0.1875 0.1875 0.1875 0.1875 0.1875 -- 0.5 0.5 0.5
 0.5 0.5 0.5 0.5 -- 0.8125 0.8125 0.8125 0.8125 0.8125 0.8125 0.8125 --
 0.96875 0.96875 0.96875 0.96875 0.96875 0.96875 0.96875 -- 1.0 1.0 1.0 1.0],
             mask = [ True False False False False  True False False False False False False
 False  True False False False False False False False  True False False
 False False False False False  True False False False False False False
 False  True False False False False False False False  True False False
 False False],
       fill_value = 1e+20)</code></pre>

<p>Y se obtiene un diagrama similar a este:<figure id="attachment_237" style="width: 300px" class="wp-caption aligncenter"></p>
<p><a href="http://new.pybonacci.org/images/2012/04/binomial5_05_cdf.png"><img class="size-medium wp-image-237" title="Distribución binomial (5, 1/2)" src="http://new.pybonacci.org/images/2012/04/binomial5_05_cdf.png?w=300" alt="" width="300" height="225" srcset="https://pybonacci.org/wp-content/uploads/2012/04/binomial5_05_cdf.png 800w, https://pybonacci.org/wp-content/uploads/2012/04/binomial5_05_cdf-300x225.png 300w" sizes="(max-width: 300px) 100vw, 300px" /></a><figcaption class="wp-caption-text">Función de distribución de una distribución binomial (5, 1/2)</figcaption></figure> </p>
<h3>Definir distribuciones</h3>
<p>Definir nuevas distribuciones discretas es aún más sencillo que en el caso continuo. Igual que antes, podemos crear una clase que extienda de, en este caso, <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_discrete.html"><code>rv_discrete</code></a>, pero ahora demás podemos construir la distribución directamente pasando los $(x_k, p_k)$ al constructor. Por ejemplo, si queremos construir una distribución discreta con los siguientes datos:</p>
<table>
  <tr>
    <th>
      $x_k$
    </th>

    <td>
      1
    </td>

    <td>
      2
    </td>

    <td>
      3
    </td>

    <td>
      4
    </td>
  </tr>

  <tr>
    <th>
      $p_k$
    </th>

    <td>
      0.1
    </td>

    <td>
      0.4
    </td>

    <td>
      0.2
    </td>

    <td>
      0.3
    </td>
  </tr>
</table>

<p>el código será el siguiente:</p>
<pre><code class="language-python">In [45]: xk = [1, 2, 3, 4]
In [46]: pk = [0.1, 0.4, 0.2, 0.3]
In [47]: rv = st.rv_discrete(xk[0], xk[-1], values=(xk, pk))</code></pre>

<p>y ya podemos acceder a todos los métodos que hemos visto anteriormente con normalidad.</p>
<p>Aquí se termina la primera parte de esta introducción al cálculo estadístico con SciPy. Espero que te haya resultado útil; no olvides difundirlo en las redes sociales y comentar lo que te apetezca.</p>
<p>¡Un saludo!</p>
        </div>

        <div class="meta">
            <div class="tags">
                    <a href="http://pybonacci.github.io/tag/estadistica.html" class="tag">Estadística</a>
                    <a href="http://pybonacci.github.io/tag/matplotlib.html" class="tag">matplotlib</a>
                    <a href="http://pybonacci.github.io/tag/numpy.html" class="tag">numpy</a>
                    <a href="http://pybonacci.github.io/tag/python.html" class="tag">python</a>
                    <a href="http://pybonacci.github.io/tag/scipy.html" class="tag">scipy</a>
            </div>
        </div>


    </article>
<script data-isso="//https://comments.pybonacci.org"
        data-isso-lang="es"
        src="//https://comments.pybonacci.org/js/embed.min.js"></script>
<section id="isso-thread">
<h3>Comentarios</h3>
</section>

</div>

<style type="text/css">
{
    max-width: 700px;
}

.text_cell .prompt {
    display: none;
}

div.cell {
    padding: 0;
}

div.text_cell_render {
    padding: 0;
}

div.prompt {
    font-size: 13px;
}

div.input_prompt {
    padding: .7em 0.2em;
}

div.output_prompt {
    padding: .4em .2em;
}

div.input_area {
    margin: .2em 0.4em;
    max-width: 580px;
}

table.dataframe {
    font-family: Arial, sans-serif;
    font-size: 13px;
    line-height: 20px;
}

table.dataframe th, td {
    padding: 4px;
    text-align: left;
}

pre code {
    background-color: inherit;
}</style>

        </div>

        <footer class="disclaimer">
          <div class="container-fluid">
            <p>
              © 2012-2017 Pybonacci, licencia <a href="https://github.com/Pybonacci/pybonacci.github.io/blob/sources/LICENSE.md"> CC BY-SA 4.0 + MIT</a>
              salvo otra indicación.
              <p>Contenido generado con <a href= "http://docs.getpelican.com/">Pelican</a>.</p>
            </p>
          </div>
        </footer>

    </body>
</html>